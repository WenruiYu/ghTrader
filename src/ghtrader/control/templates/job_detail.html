{% extends "base.html" %}
{% block content %}
  <div class="section-header">
    <h2 class="mono">Job {{ job.id }}</h2>
    <div class="section-header-actions">
      <a class="btn btn-secondary btn-sm" href="/jobs{{ token_qs }}">Back</a>
      <a class="btn btn-secondary btn-sm" href="/jobs/{{ job.id }}{{ token_qs }}">Refresh</a>
    </div>
  </div>

  <div class="card">
    <div><b>Status:</b> <span class="pill pill-{{ job.status }}" id="jobStatusPill">{{ job.status }}</span></div>
    <div><b>Title:</b> {{ job.title }}</div>
    <div><b>Source:</b> <span class="mono">{{ job.source or "" }}</span></div>
    <div><b>PID:</b> <span class="mono">{{ job.pid or "" }}</span></div>
    <div><b>Exit:</b> <span class="mono">{{ job.exit_code if job.exit_code is not none else "" }}</span></div>
    <div><b>Created:</b> <span class="mono">{{ job.created_at }}</span></div>
    <div><b>Started:</b> <span class="mono">{{ job.started_at or "" }}</span></div>
    <div><b>Finished:</b> <span class="mono">{{ job.finished_at or "" }}</span></div>
    <div><b>Command:</b> <span class="mono" id="jobCommand">{{ job.command | join(" ") }}</span></div>
    <div><b>Log:</b> <span class="mono" id="jobLogPath">{{ job.log_path or "" }}</span></div>
    <div><b>Waiting locks:</b> <span class="mono">{{ (job.waiting_locks or []) | join(",") }}</span></div>
    <div><b>Held locks:</b> <span class="mono">{{ (job.held_locks or []) | join(",") }}</span></div>

    {% if job.status in ["queued", "running"] %}
      <form method="post" action="/jobs/{{ job.id }}/cancel{{ token_qs }}">
        <button class="btn btn-danger btn-sm" type="submit">Cancel</button>
      </form>
    {% endif %}
  </div>

  <h3>Ingest status</h3>
  <div class="card" id="ingestCard" style="display:none;">
    <div><b>Kind:</b> <span class="mono" id="ingestKind"></span></div>
    <div><b>Current:</b> <span class="mono" id="ingestCurrent"></span></div>
    <div><b>Progress:</b> <span class="mono" id="ingestProgress"></span></div>
    <div id="ingestLastErrorRow" style="display:none;"><b>Last error:</b> <span class="mono text-xs" id="ingestLastError"></span></div>
    <div class="muted">For full details, see <a href="/ops/ingest{{ token_qs }}">Ingest</a>.</div>
  </div>

  <h3>Log tail</h3>
  <div class="card">
    <div class="inlineControls">
      <label><input type="checkbox" id="autoScroll" checked/> autoscroll</label>
      <label><input type="checkbox" id="pausePolling"/> pause polling</label>
      <label for="pollMs">poll</label>
      <select id="pollMs">
        <option value="1000">1s</option>
        <option value="2000" selected>2s</option>
        <option value="5000">5s</option>
        <option value="10000">10s</option>
      </select>
      <button type="button" class="btn btn-secondary" id="copyJobId">Copy job id</button>
      <button type="button" class="btn btn-secondary" id="copyCmd">Copy command</button>
      <button type="button" class="btn btn-secondary" id="copyLogPath">Copy log path</button>
      <a class="btn btn-secondary" href="/api/jobs/{{ job.id }}/log/download{{ token_qs }}">Download full log</a>
    </div>
    <p class="muted" style="margin:10px 0 0;">
      Tip: polling pauses when the tab is hidden and stops when the job finishes.
    </p>
  </div>

  <pre class="log" id="logBox">{{ log_text }}</pre>

  <script>
    (function() {
      const logUrl = "/api/jobs/{{ job.id }}/log{{ token_qs }}";
      const ingestUrl = "/api/jobs/{{ job.id }}/ingest_status{{ token_qs }}";
      const statusUrl = "/api/jobs{{ token_qs }}";
      const box = document.getElementById("logBox");
      const ingestCard = document.getElementById("ingestCard");
      const ingestKind = document.getElementById("ingestKind");
      const ingestCurrent = document.getElementById("ingestCurrent");
      const ingestProgress = document.getElementById("ingestProgress");
      const ingestLastErrorRow = document.getElementById("ingestLastErrorRow");
      const ingestLastError = document.getElementById("ingestLastError");
      const pill = document.getElementById("jobStatusPill");
      const autoScroll = document.getElementById("autoScroll");
      const pausePolling = document.getElementById("pausePolling");
      const pollMs = document.getElementById("pollMs");

      const jobId = "{{ job.id }}";
      let isActive = (("{{ job.status }}" === "running") || ("{{ job.status }}" === "queued"));
      let logTimer = null;
      let statusTimer = null;
      let ingestTimer = null;

      // Ingest speed/ETA (best-effort, computed from ingest_status deltas)
      let ingestLastAtMs = null;
      let ingestLastDone = null;
      let ingestFirstAtMs = null;
      let ingestFirstDone = null;

      function fmtPct(x) {
        if (x === null || x === undefined) return "-";
        return (Math.round(x * 1000) / 10).toFixed(1) + "%";
      }

      function fmtDurationSec(sec) {
        const s = Math.max(0, Math.floor(sec || 0));
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        if (h > 0) return h + "h" + String(m).padStart(2, "0") + "m";
        if (m > 0) return m + "m" + String(ss).padStart(2, "0") + "s";
        return ss + "s";
      }

      function fmtSpeedDaysPerMin(x) {
        if (x === null || x === undefined) return "";
        const v = Number(x);
        if (!isFinite(v) || v <= 0) return "";
        return (Math.round(v * 100) / 100).toFixed(2) + " days/min";
      }

      async function copyText(s) {
        const txt = String(s || "");
        try {
          await navigator.clipboard.writeText(txt);
        } catch (e) {
          window.prompt("Copy to clipboard:", txt);
        }
      }

      function setPill(status) {
        if (!pill) return;
        pill.textContent = status || "";
        pill.className = "pill pill-" + (status || "queued");
      }

      async function tick() {
        try {
          const resp = await fetch(logUrl);
          if (!resp.ok) return;
          const txt = await resp.text();
          box.textContent = txt;
          if (autoScroll && autoScroll.checked) {
            box.scrollTop = box.scrollHeight;
          }
        } catch (e) {}
      }

      async function tickIngest() {
        try {
          const resp = await fetch(ingestUrl);
          if (!resp.ok) return;
          const s = await resp.json();
          if (!s || !s.kind || s.kind === "unknown") {
            ingestCard.style.display = "none";
            return;
          }
          ingestCard.style.display = "block";
          ingestKind.textContent = s.kind || "";
          if (ingestLastErrorRow && ingestLastError) {
            const le = String(s.last_error_line || "").trim();
            if (le) {
              ingestLastErrorRow.style.display = "block";
              ingestLastError.textContent = le;
            } else {
              ingestLastErrorRow.style.display = "none";
              ingestLastError.textContent = "";
            }
          }

          if (s.kind === "download_contract_range") {
            ingestCurrent.textContent = s.current_symbol || "";
            const sum = s.summary || {};
            const done = (sum.days_done_total ?? null);
            const expected = (sum.days_expected_total ?? null);
            const nowMs = Date.now();
            if (ingestFirstAtMs === null && done !== null) { ingestFirstAtMs = nowMs; ingestFirstDone = done; }
            let speedText = "";
            let etaText = "";
            if (done !== null) {
              if (ingestLastAtMs !== null && ingestLastDone !== null) {
                const dtSec = (nowMs - ingestLastAtMs) / 1000.0;
                const dd = Number(done) - Number(ingestLastDone);
                const sp = (dtSec > 0) ? (dd / dtSec) * 60.0 : 0;
                const spTxt = fmtSpeedDaysPerMin(sp);
                if (spTxt) speedText = spTxt;
                if (expected !== null && sp > 0) {
                  const rem = Math.max(0, Number(expected) - Number(done));
                  etaText = "ETA " + fmtDurationSec((rem / sp) * 60.0);
                }
              } else if (ingestFirstAtMs !== null && ingestFirstDone !== null) {
                const dtSec = (nowMs - ingestFirstAtMs) / 1000.0;
                const dd = Number(done) - Number(ingestFirstDone);
                const sp = (dtSec > 0) ? (dd / dtSec) * 60.0 : 0;
                const spTxt = fmtSpeedDaysPerMin(sp);
                if (spTxt) speedText = spTxt;
              }
            }
            ingestLastAtMs = nowMs; ingestLastDone = done;
            const extra = [speedText, etaText].filter(Boolean).join(", ");
            ingestProgress.textContent =
              fmtPct(sum.pct) +
              " days " + (sum.days_done_total ?? "") + "/" + (sum.days_expected_total ?? "") +
              " contracts " + (sum.contracts_done ?? "") + "/" + (sum.contracts_total ?? "") +
              (extra ? (" (" + extra + ")") : "");
          } else if (s.kind === "download") {
            ingestCurrent.textContent = s.symbol || "";
            const sum = s.summary || {};
            const done = (sum.days_done ?? null);
            const expected = (sum.days_expected ?? null);
            const nowMs = Date.now();
            if (ingestFirstAtMs === null && done !== null) { ingestFirstAtMs = nowMs; ingestFirstDone = done; }
            let speedText = "";
            let etaText = "";
            if (done !== null) {
              if (ingestLastAtMs !== null && ingestLastDone !== null) {
                const dtSec = (nowMs - ingestLastAtMs) / 1000.0;
                const dd = Number(done) - Number(ingestLastDone);
                const sp = (dtSec > 0) ? (dd / dtSec) * 60.0 : 0;
                const spTxt = fmtSpeedDaysPerMin(sp);
                if (spTxt) speedText = spTxt;
                if (expected !== null && sp > 0) {
                  const rem = Math.max(0, Number(expected) - Number(done));
                  etaText = "ETA " + fmtDurationSec((rem / sp) * 60.0);
                }
              } else if (ingestFirstAtMs !== null && ingestFirstDone !== null) {
                const dtSec = (nowMs - ingestFirstAtMs) / 1000.0;
                const dd = Number(done) - Number(ingestFirstDone);
                const sp = (dtSec > 0) ? (dd / dtSec) * 60.0 : 0;
                const spTxt = fmtSpeedDaysPerMin(sp);
                if (spTxt) speedText = spTxt;
              }
            }
            ingestLastAtMs = nowMs; ingestLastDone = done;
            const extra = [speedText, etaText].filter(Boolean).join(", ");
            ingestProgress.textContent =
              fmtPct(sum.pct) +
              " days " + (sum.days_done ?? "") + "/" + (sum.days_expected ?? "") +
              (s.chunk_idx ? (" chunk_idx=" + s.chunk_idx) : "") +
              (extra ? (" (" + extra + ")") : "");
          } else {
            ingestCurrent.textContent = s.current_symbol || "";
            ingestProgress.textContent = "-";
          }
        } catch (e) {}
      }

      async function tickStatus() {
        try {
          const resp = await fetch(statusUrl);
          if (!resp.ok) return;
          const data = await resp.json();
          const jobs = data.jobs || [];
          const j = jobs.find(x => x && x.id === jobId);
          if (!j) return;
          const st = j.status || "";
          setPill(st);
          if (st === "running" || st === "queued") {
            isActive = true;
          } else {
            isActive = false;
            stopPolling();
          }
        } catch (e) {}
      }

      function stopPolling() {
        if (logTimer) { clearInterval(logTimer); logTimer = null; }
        if (ingestTimer) { clearInterval(ingestTimer); ingestTimer = null; }
        if (statusTimer) { clearInterval(statusTimer); statusTimer = null; }
      }

      function startPolling() {
        stopPolling();
        const ms = pollMs ? parseInt(pollMs.value, 10) : 2000;
        if (!pausePolling || !pausePolling.checked) {
          logTimer = setInterval(tick, ms);
          statusTimer = setInterval(tickStatus, Math.max(2000, ms));
          ingestTimer = setInterval(tickIngest, 10000);
          tick();
          tickStatus();
          tickIngest();
        }
      }

      function maybePauseForVisibility() {
        if (document.hidden) {
          stopPolling();
          return;
        }
        if (!isActive) return;
        startPolling();
      }

      if (pausePolling) {
        pausePolling.addEventListener("change", () => {
          if (pausePolling.checked) {
            stopPolling();
          } else {
            if (isActive) startPolling();
          }
        });
      }
      if (pollMs) pollMs.addEventListener("change", () => { if (isActive) startPolling(); });
      document.addEventListener("visibilitychange", maybePauseForVisibility);

      const btnCopyId = document.getElementById("copyJobId");
      const btnCopyCmd = document.getElementById("copyCmd");
      const btnCopyLog = document.getElementById("copyLogPath");
      if (btnCopyId) btnCopyId.addEventListener("click", () => copyText(jobId));
      if (btnCopyCmd) btnCopyCmd.addEventListener("click", () => copyText(document.getElementById("jobCommand").textContent));
      if (btnCopyLog) btnCopyLog.addEventListener("click", () => copyText(document.getElementById("jobLogPath").textContent));

      // Start polling if active (queued/running); otherwise do one-time fetch.
      if (isActive) {
        startPolling();
      } else {
        tick();
        tickIngest();
      }
    })();
  </script>
{% endblock %}

