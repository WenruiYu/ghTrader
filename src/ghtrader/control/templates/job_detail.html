{% extends "base.html" %}
{% block content %}
  {% set var_query = token_qs ~ ("&" if token_qs else "?") ~ "var=" ~ variety %}
  <div class="section-header">
    <h2 class="mono">Job {{ job.id }}</h2>
    <div class="section-header-actions">
      <a class="btn btn-secondary btn-sm" href="{{ variety_path_prefix }}/jobs{{ token_qs }}">Back</a>
      <a class="btn btn-secondary btn-sm" href="/jobs/{{ job.id }}{{ var_query }}">Refresh</a>
    </div>
  </div>

  <div class="card">
    {% set job_meta = job.metadata if job.metadata is mapping else {} %}
    <div><b>Status:</b> <span class="pill pill-{{ job.status }}" id="jobStatusPill">{{ job.status }}</span></div>
    <div><b>Title:</b> {{ job.title }}</div>
    <div><b>Source:</b> <span class="mono">{{ job.source or "" }}</span></div>
    <div><b>Kind:</b> <span class="mono">{{ job_meta.get("kind") or "--" }}</span></div>
    <div><b>Variety:</b> <span class="mono">{{ job_meta.get("variety") or "--" }}</span></div>
    <div><b>Symbol:</b> <span class="mono">{{ job_meta.get("symbol") or ((job_meta.get("symbols") or []) | join(",")) or "--" }}</span></div>
    <div><b>Account profile:</b> <span class="mono">{{ job_meta.get("account_profile") or "--" }}</span></div>
    <div><b>PID:</b> <span class="mono">{{ job.pid or "" }}</span></div>
    <div><b>Exit:</b> <span class="mono">{{ job.exit_code if job.exit_code is not none else "" }}</span></div>
    <div><b>Created:</b> <span class="mono">{{ job.created_at }}</span></div>
    <div><b>Started:</b> <span class="mono">{{ job.started_at or "" }}</span></div>
    <div><b>Finished:</b> <span class="mono">{{ job.finished_at or "" }}</span></div>
    <div><b>Command:</b> <span class="mono" id="jobCommand">{{ job.command | join(" ") }}</span></div>
    <div><b>Log:</b> <span class="mono" id="jobLogPath">{{ job.log_path or "" }}</span></div>
    <div><b>Waiting locks:</b> <span class="mono">{{ (job.waiting_locks or []) | join(",") }}</span></div>
    <div><b>Held locks:</b> <span class="mono">{{ (job.held_locks or []) | join(",") }}</span></div>

    {% if job.status in ["queued", "running"] %}
      <form method="post" action="/jobs/{{ job.id }}/cancel{{ var_query }}">
        <button class="btn btn-danger btn-sm" type="submit">Cancel</button>
      </form>
    {% endif %}
  </div>

  <h3>Job Progress</h3>
  <div class="card" id="progressCard" hidden>
    <div class="job-progress-layout">
      <div class="job-progress-row">
        <b>State:</b>
        <span class="mono" id="progressState">-</span>
      </div>
      <div class="job-progress-row">
        <b>Phase:</b>
        <span class="mono" id="progressPhase">-</span>
        <span class="muted text-xs" id="progressPhaseIdx"></span>
      </div>
      <div class="job-progress-row">
        <b>Step:</b>
        <span class="mono" id="progressStep">-</span>
        <span class="muted text-xs" id="progressStepIdx"></span>
      </div>
      <div id="progressItemRow" class="job-progress-row-inline" hidden>
        <b>Current:</b>
        <span class="mono" id="progressItem">-</span>
        <span class="muted text-xs" id="progressItemIdx"></span>
      </div>
      <div class="job-progress-row">
        <b>Message:</b>
        <span id="progressMessage">-</span>
      </div>
    </div>
    <div class="job-progress-layout">
      <div class="job-progress-stack">
        <div class="flex-1">
          <div class="progressBar progressBar-lg">
            <div id="progressBarFill" class="job-progress-fill"></div>
          </div>
        </div>
        <span class="mono job-progress-pct" id="progressPct">0%</span>
        <span class="muted mono job-progress-eta" id="progressEta">-</span>
      </div>
    </div>
    <div id="progressErrorRow" class="job-progress-error" hidden>
      <b>Error:</b> <span class="mono text-xs" id="progressError"></span>
    </div>
  </div>


  <h3>Log tail</h3>
  <div class="card">
    <div class="inlineControls">
      <label><input type="checkbox" id="autoScroll" checked/> autoscroll</label>
      <label><input type="checkbox" id="pausePolling"/> pause polling</label>
      <label for="pollMs">poll</label>
      <select id="pollMs">
        <option value="1000">1s</option>
        <option value="2000" selected>2s</option>
        <option value="5000">5s</option>
        <option value="10000">10s</option>
      </select>
      <button type="button" class="btn btn-secondary" id="copyJobId">Copy job id</button>
      <button type="button" class="btn btn-secondary" id="copyCmd">Copy command</button>
      <button type="button" class="btn btn-secondary" id="copyLogPath">Copy log path</button>
      <a class="btn btn-secondary" href="/api/jobs/{{ job.id }}/log/download{{ token_qs }}">Download full log</a>
    </div>
    <p class="muted mt-3">
      Tip: polling pauses when the tab is hidden and stops when the job finishes.
    </p>
  </div>

  <pre class="log" id="logBox">{{ log_text }}</pre>

  <script>
    (function() {
      const logUrl = "/api/jobs/{{ job.id }}/log{{ token_qs }}";
      const progressUrl = "/api/jobs/{{ job.id }}/progress{{ token_qs }}";
      const statusUrl = "/api/jobs{{ token_qs }}";
      const box = document.getElementById("logBox");
      const pill = document.getElementById("jobStatusPill");
      const autoScroll = document.getElementById("autoScroll");
      const pausePolling = document.getElementById("pausePolling");
      const pollMs = document.getElementById("pollMs");

      // Progress card elements
      const progressCard = document.getElementById("progressCard");
      const progressPhase = document.getElementById("progressPhase");
      const progressPhaseIdx = document.getElementById("progressPhaseIdx");
      const progressStep = document.getElementById("progressStep");
      const progressStepIdx = document.getElementById("progressStepIdx");
      const progressItemRow = document.getElementById("progressItemRow");
      const progressItem = document.getElementById("progressItem");
      const progressItemIdx = document.getElementById("progressItemIdx");
      const progressMessage = document.getElementById("progressMessage");
      const progressState = document.getElementById("progressState");
      const progressBarFill = document.getElementById("progressBarFill");
      const progressPct = document.getElementById("progressPct");
      const progressEta = document.getElementById("progressEta");
      const progressErrorRow = document.getElementById("progressErrorRow");
      const progressError = document.getElementById("progressError");

      const jobId = "{{ job.id }}";
      let isActive = (("{{ job.status }}" === "running") || ("{{ job.status }}" === "queued"));
      let logTimer = null;
      let statusTimer = null;
      let progressTimer = null;

      function fmtPct(x) {
        if (x === null || x === undefined) return "-";
        return (Math.round(x * 1000) / 10).toFixed(1) + "%";
      }

      function fmtDurationSec(sec) {
        const s = Math.max(0, Math.floor(sec || 0));
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        if (h > 0) return h + "h" + String(m).padStart(2, "0") + "m";
        if (m > 0) return m + "m" + String(ss).padStart(2, "0") + "s";
        return ss + "s";
      }


      async function copyText(s) {
        const txt = String(s || "");
        try {
          await navigator.clipboard.writeText(txt);
        } catch (e) {
          window.prompt("Copy to clipboard:", txt);
        }
      }

      function setPill(status) {
        if (!pill) return;
        pill.textContent = status || "";
        pill.className = "pill pill-" + (status || "queued");
      }

      async function tick() {
        try {
          const resp = await fetch(logUrl);
          if (!resp.ok) return;
          const txt = await resp.text();
          box.textContent = txt;
          if (autoScroll && autoScroll.checked) {
            box.scrollTop = box.scrollHeight;
          }
        } catch (e) {}
      }

      async function tickProgress() {
        try {
          const resp = await fetch(progressUrl);
          if (!resp.ok) return;
          const p = await resp.json();
          if (!p || !p.available) {
            progressCard.hidden = true;
            return;
          }
          progressCard.hidden = false;
          if (progressState) {
            const st = String(p.state || p.job_status || "").trim();
            progressState.textContent = st || "-";
          }

          // Phase
          progressPhase.textContent = p.phase || "-";
          if (p.total_phases > 1) {
            progressPhaseIdx.textContent = "(" + (p.phase_idx + 1) + "/" + p.total_phases + ")";
          } else {
            progressPhaseIdx.textContent = "";
          }

          // Step
          progressStep.textContent = p.step || "-";
          if (p.total_steps > 1) {
            progressStepIdx.textContent = "(" + (p.step_idx + 1) + "/" + p.total_steps + ")";
          } else {
            progressStepIdx.textContent = "";
          }

          // Item (optional)
          if (p.total_items > 0 && p.item) {
            progressItemRow.hidden = false;
            progressItem.textContent = p.item;
            progressItemIdx.textContent = "(" + p.item_idx + "/" + p.total_items + ")";
          } else {
            progressItemRow.hidden = true;
          }

          // Message
          progressMessage.textContent = p.message || "-";

          // Progress bar
          const pctVal = Math.min(100, Math.max(0, (p.pct || 0) * 100));
          progressBarFill.style.width = pctVal.toFixed(1) + "%";
          progressPct.textContent = pctVal.toFixed(1) + "%";

          // ETA
          if (p.eta_seconds !== null && p.eta_seconds !== undefined) {
            progressEta.textContent = "ETA " + fmtDurationSec(p.eta_seconds);
          } else {
            progressEta.textContent = "-";
          }
          if (p.stale && p.updated_age_s !== null && p.updated_age_s !== undefined) {
            progressEta.textContent += " Â· stale " + String(p.updated_age_s) + "s";
          }

          // Error
          if (p.error) {
            progressErrorRow.hidden = false;
            progressError.textContent = p.error;
          } else {
            progressErrorRow.hidden = true;
          }
        } catch (e) {}
      }

      async function tickStatus() {
        try {
          const resp = await fetch(statusUrl);
          if (!resp.ok) return;
          const data = await resp.json();
          const jobs = data.jobs || [];
          const j = jobs.find(x => x && x.id === jobId);
          if (!j) return;
          const st = j.status || "";
          setPill(st);
          if (st === "running" || st === "queued") {
            isActive = true;
          } else {
            isActive = false;
            stopPolling();
          }
        } catch (e) {}
      }

      function stopPolling() {
        if (logTimer) { clearInterval(logTimer); logTimer = null; }
        if (statusTimer) { clearInterval(statusTimer); statusTimer = null; }
        if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
      }

      function startPolling() {
        stopPolling();
        const ms = pollMs ? parseInt(pollMs.value, 10) : 2000;
        if (!pausePolling || !pausePolling.checked) {
          logTimer = setInterval(tick, ms);
          statusTimer = setInterval(tickStatus, Math.max(2000, ms));
          progressTimer = setInterval(tickProgress, 2000);
          tick();
          tickStatus();
          tickProgress();
        }
      }

      function maybePauseForVisibility() {
        if (document.hidden) {
          stopPolling();
          return;
        }
        if (!isActive) return;
        startPolling();
      }

      if (pausePolling) {
        pausePolling.addEventListener("change", () => {
          if (pausePolling.checked) {
            stopPolling();
          } else {
            if (isActive) startPolling();
          }
        });
      }
      if (pollMs) pollMs.addEventListener("change", () => { if (isActive) startPolling(); });
      document.addEventListener("visibilitychange", maybePauseForVisibility);

      const btnCopyId = document.getElementById("copyJobId");
      const btnCopyCmd = document.getElementById("copyCmd");
      const btnCopyLog = document.getElementById("copyLogPath");
      if (btnCopyId) btnCopyId.addEventListener("click", () => copyText(jobId));
      if (btnCopyCmd) btnCopyCmd.addEventListener("click", () => copyText(document.getElementById("jobCommand").textContent));
      if (btnCopyLog) btnCopyLog.addEventListener("click", () => copyText(document.getElementById("jobLogPath").textContent));

      // Start polling if active (queued/running); otherwise do one-time fetch.
      if (isActive) {
        startPolling();
      } else {
        tick();
        tickProgress();
      }
    })();
  </script>
{% endblock %}

