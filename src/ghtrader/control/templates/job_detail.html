{% extends "base.html" %}
{% block content %}
  <div class="section-header">
    <h2 class="mono">Job {{ job.id }}</h2>
    <div class="section-header-actions">
      <a class="btn btn-secondary btn-sm" href="/jobs{{ token_qs }}">Back</a>
      <a class="btn btn-secondary btn-sm" href="/jobs/{{ job.id }}{{ token_qs }}">Refresh</a>
    </div>
  </div>

  <div class="card">
    <div><b>Status:</b> <span class="pill pill-{{ job.status }}" id="jobStatusPill">{{ job.status }}</span></div>
    <div><b>Title:</b> {{ job.title }}</div>
    <div><b>Source:</b> <span class="mono">{{ job.source or "" }}</span></div>
    <div><b>PID:</b> <span class="mono">{{ job.pid or "" }}</span></div>
    <div><b>Exit:</b> <span class="mono">{{ job.exit_code if job.exit_code is not none else "" }}</span></div>
    <div><b>Created:</b> <span class="mono">{{ job.created_at }}</span></div>
    <div><b>Started:</b> <span class="mono">{{ job.started_at or "" }}</span></div>
    <div><b>Finished:</b> <span class="mono">{{ job.finished_at or "" }}</span></div>
    <div><b>Command:</b> <span class="mono" id="jobCommand">{{ job.command | join(" ") }}</span></div>
    <div><b>Log:</b> <span class="mono" id="jobLogPath">{{ job.log_path or "" }}</span></div>
    <div><b>Waiting locks:</b> <span class="mono">{{ (job.waiting_locks or []) | join(",") }}</span></div>
    <div><b>Held locks:</b> <span class="mono">{{ (job.held_locks or []) | join(",") }}</span></div>

    {% if job.status in ["queued", "running"] %}
      <form method="post" action="/jobs/{{ job.id }}/cancel{{ token_qs }}">
        <button class="btn btn-danger btn-sm" type="submit">Cancel</button>
      </form>
    {% endif %}
  </div>

  <h3>Job Progress</h3>
  <div class="card" id="progressCard" style="display:none;">
    <div style="margin-bottom:8px;">
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
        <b>Phase:</b>
        <span class="mono" id="progressPhase">-</span>
        <span class="muted text-xs" id="progressPhaseIdx"></span>
      </div>
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
        <b>Step:</b>
        <span class="mono" id="progressStep">-</span>
        <span class="muted text-xs" id="progressStepIdx"></span>
      </div>
      <div id="progressItemRow" style="display:none; margin-bottom:4px;">
        <b>Current:</b>
        <span class="mono" id="progressItem">-</span>
        <span class="muted text-xs" id="progressItemIdx"></span>
      </div>
      <div style="margin-bottom:4px;">
        <b>Message:</b>
        <span id="progressMessage">-</span>
      </div>
    </div>
    <div style="margin-bottom:8px;">
      <div style="display:flex; align-items:center; gap:12px;">
        <div style="flex:1;">
          <div class="progressBar" style="height:12px;">
            <div id="progressBarFill" style="width:0%; transition:width 0.3s;"></div>
          </div>
        </div>
        <span class="mono" id="progressPct" style="min-width:50px; text-align:right;">0%</span>
        <span class="muted mono" id="progressEta" style="min-width:80px;">-</span>
      </div>
    </div>
    <div id="progressErrorRow" style="display:none; color:var(--danger);">
      <b>Error:</b> <span class="mono text-xs" id="progressError"></span>
    </div>
  </div>

  <h3>Ingest status</h3>
  <div class="card" id="ingestCard" style="display:none;">
    <div><b>Kind:</b> <span class="mono" id="ingestKind"></span></div>
    <div><b>Current:</b> <span class="mono" id="ingestCurrent"></span></div>
    <div><b>Progress:</b> <span class="mono" id="ingestProgress"></span></div>
    <div id="ingestLastErrorRow" style="display:none;"><b>Last error:</b> <span class="mono text-xs" id="ingestLastError"></span></div>
    <div class="muted">For full details, see <a href="/data{{ token_qs }}#ingest">Ingest</a>.</div>
  </div>

  <h3>Log tail</h3>
  <div class="card">
    <div class="inlineControls">
      <label><input type="checkbox" id="autoScroll" checked/> autoscroll</label>
      <label><input type="checkbox" id="pausePolling"/> pause polling</label>
      <label for="pollMs">poll</label>
      <select id="pollMs">
        <option value="1000">1s</option>
        <option value="2000" selected>2s</option>
        <option value="5000">5s</option>
        <option value="10000">10s</option>
      </select>
      <button type="button" class="btn btn-secondary" id="copyJobId">Copy job id</button>
      <button type="button" class="btn btn-secondary" id="copyCmd">Copy command</button>
      <button type="button" class="btn btn-secondary" id="copyLogPath">Copy log path</button>
      <a class="btn btn-secondary" href="/api/jobs/{{ job.id }}/log/download{{ token_qs }}">Download full log</a>
    </div>
    <p class="muted" style="margin:10px 0 0;">
      Tip: polling pauses when the tab is hidden and stops when the job finishes.
    </p>
  </div>

  <pre class="log" id="logBox">{{ log_text }}</pre>

  <script>
    (function() {
      const logUrl = "/api/jobs/{{ job.id }}/log{{ token_qs }}";
      const ingestUrl = "/api/jobs/{{ job.id }}/ingest_status{{ token_qs }}";
      const progressUrl = "/api/jobs/{{ job.id }}/progress{{ token_qs }}";
      const statusUrl = "/api/jobs{{ token_qs }}";
      const box = document.getElementById("logBox");
      const ingestCard = document.getElementById("ingestCard");
      const ingestKind = document.getElementById("ingestKind");
      const ingestCurrent = document.getElementById("ingestCurrent");
      const ingestProgress = document.getElementById("ingestProgress");
      const ingestLastErrorRow = document.getElementById("ingestLastErrorRow");
      const ingestLastError = document.getElementById("ingestLastError");
      const pill = document.getElementById("jobStatusPill");
      const autoScroll = document.getElementById("autoScroll");
      const pausePolling = document.getElementById("pausePolling");
      const pollMs = document.getElementById("pollMs");

      // Progress card elements
      const progressCard = document.getElementById("progressCard");
      const progressPhase = document.getElementById("progressPhase");
      const progressPhaseIdx = document.getElementById("progressPhaseIdx");
      const progressStep = document.getElementById("progressStep");
      const progressStepIdx = document.getElementById("progressStepIdx");
      const progressItemRow = document.getElementById("progressItemRow");
      const progressItem = document.getElementById("progressItem");
      const progressItemIdx = document.getElementById("progressItemIdx");
      const progressMessage = document.getElementById("progressMessage");
      const progressBarFill = document.getElementById("progressBarFill");
      const progressPct = document.getElementById("progressPct");
      const progressEta = document.getElementById("progressEta");
      const progressErrorRow = document.getElementById("progressErrorRow");
      const progressError = document.getElementById("progressError");

      const jobId = "{{ job.id }}";
      let isActive = (("{{ job.status }}" === "running") || ("{{ job.status }}" === "queued"));
      let logTimer = null;
      let statusTimer = null;
      let ingestTimer = null;
      let progressTimer = null;

      // Ingest speed/ETA (best-effort, computed from ingest_status deltas)
      let ingestLastAtMs = null;
      let ingestLastDone = null;
      let ingestFirstAtMs = null;
      let ingestFirstDone = null;

      function fmtPct(x) {
        if (x === null || x === undefined) return "-";
        return (Math.round(x * 1000) / 10).toFixed(1) + "%";
      }

      function fmtDurationSec(sec) {
        const s = Math.max(0, Math.floor(sec || 0));
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const ss = s % 60;
        if (h > 0) return h + "h" + String(m).padStart(2, "0") + "m";
        if (m > 0) return m + "m" + String(ss).padStart(2, "0") + "s";
        return ss + "s";
      }

      function fmtSpeedDaysPerMin(x) {
        if (x === null || x === undefined) return "";
        const v = Number(x);
        if (!isFinite(v) || v <= 0) return "";
        return (Math.round(v * 100) / 100).toFixed(2) + " days/min";
      }

      async function copyText(s) {
        const txt = String(s || "");
        try {
          await navigator.clipboard.writeText(txt);
        } catch (e) {
          window.prompt("Copy to clipboard:", txt);
        }
      }

      function setPill(status) {
        if (!pill) return;
        pill.textContent = status || "";
        pill.className = "pill pill-" + (status || "queued");
      }

      async function tick() {
        try {
          const resp = await fetch(logUrl);
          if (!resp.ok) return;
          const txt = await resp.text();
          box.textContent = txt;
          if (autoScroll && autoScroll.checked) {
            box.scrollTop = box.scrollHeight;
          }
        } catch (e) {}
      }

      async function tickIngest() {
        try {
          const resp = await fetch(ingestUrl);
          if (!resp.ok) return;
          const s = await resp.json();
          if (!s || !s.kind || s.kind === "unknown") {
            ingestCard.style.display = "none";
            return;
          }
          ingestCard.style.display = "block";
          ingestKind.textContent = s.kind || "";
          if (ingestLastErrorRow && ingestLastError) {
            const le = String(s.last_error_line || "").trim();
            if (le) {
              ingestLastErrorRow.style.display = "block";
              ingestLastError.textContent = le;
            } else {
              ingestLastErrorRow.style.display = "none";
              ingestLastError.textContent = "";
            }
          }

          if (s.kind === "download_contract_range") {
            ingestCurrent.textContent = s.current_symbol || "";
            const sum = s.summary || {};
            const done = (sum.days_done_total ?? null);
            const expected = (sum.days_expected_total ?? null);
            const nowMs = Date.now();
            if (ingestFirstAtMs === null && done !== null) { ingestFirstAtMs = nowMs; ingestFirstDone = done; }
            let speedText = "";
            let etaText = "";
            if (done !== null) {
              if (ingestLastAtMs !== null && ingestLastDone !== null) {
                const dtSec = (nowMs - ingestLastAtMs) / 1000.0;
                const dd = Number(done) - Number(ingestLastDone);
                const sp = (dtSec > 0) ? (dd / dtSec) * 60.0 : 0;
                const spTxt = fmtSpeedDaysPerMin(sp);
                if (spTxt) speedText = spTxt;
                if (expected !== null && sp > 0) {
                  const rem = Math.max(0, Number(expected) - Number(done));
                  etaText = "ETA " + fmtDurationSec((rem / sp) * 60.0);
                }
              } else if (ingestFirstAtMs !== null && ingestFirstDone !== null) {
                const dtSec = (nowMs - ingestFirstAtMs) / 1000.0;
                const dd = Number(done) - Number(ingestFirstDone);
                const sp = (dtSec > 0) ? (dd / dtSec) * 60.0 : 0;
                const spTxt = fmtSpeedDaysPerMin(sp);
                if (spTxt) speedText = spTxt;
              }
            }
            ingestLastAtMs = nowMs; ingestLastDone = done;
            const extra = [speedText, etaText].filter(Boolean).join(", ");
            ingestProgress.textContent =
              fmtPct(sum.pct) +
              " days " + (sum.days_done_total ?? "") + "/" + (sum.days_expected_total ?? "") +
              " contracts " + (sum.contracts_done ?? "") + "/" + (sum.contracts_total ?? "") +
              (extra ? (" (" + extra + ")") : "");
          } else if (s.kind === "download") {
            ingestCurrent.textContent = s.symbol || "";
            const sum = s.summary || {};
            const done = (sum.days_done ?? null);
            const expected = (sum.days_expected ?? null);
            const nowMs = Date.now();
            if (ingestFirstAtMs === null && done !== null) { ingestFirstAtMs = nowMs; ingestFirstDone = done; }
            let speedText = "";
            let etaText = "";
            if (done !== null) {
              if (ingestLastAtMs !== null && ingestLastDone !== null) {
                const dtSec = (nowMs - ingestLastAtMs) / 1000.0;
                const dd = Number(done) - Number(ingestLastDone);
                const sp = (dtSec > 0) ? (dd / dtSec) * 60.0 : 0;
                const spTxt = fmtSpeedDaysPerMin(sp);
                if (spTxt) speedText = spTxt;
                if (expected !== null && sp > 0) {
                  const rem = Math.max(0, Number(expected) - Number(done));
                  etaText = "ETA " + fmtDurationSec((rem / sp) * 60.0);
                }
              } else if (ingestFirstAtMs !== null && ingestFirstDone !== null) {
                const dtSec = (nowMs - ingestFirstAtMs) / 1000.0;
                const dd = Number(done) - Number(ingestFirstDone);
                const sp = (dtSec > 0) ? (dd / dtSec) * 60.0 : 0;
                const spTxt = fmtSpeedDaysPerMin(sp);
                if (spTxt) speedText = spTxt;
              }
            }
            ingestLastAtMs = nowMs; ingestLastDone = done;
            const extra = [speedText, etaText].filter(Boolean).join(", ");
            ingestProgress.textContent =
              fmtPct(sum.pct) +
              " days " + (sum.days_done ?? "") + "/" + (sum.days_expected ?? "") +
              (s.chunk_idx ? (" chunk_idx=" + s.chunk_idx) : "") +
              (extra ? (" (" + extra + ")") : "");
          } else {
            ingestCurrent.textContent = s.current_symbol || "";
            ingestProgress.textContent = "-";
          }
        } catch (e) {}
      }

      async function tickProgress() {
        try {
          const resp = await fetch(progressUrl);
          if (!resp.ok) return;
          const p = await resp.json();
          if (!p || !p.available) {
            progressCard.style.display = "none";
            return;
          }
          progressCard.style.display = "block";

          // Phase
          progressPhase.textContent = p.phase || "-";
          if (p.total_phases > 1) {
            progressPhaseIdx.textContent = "(" + (p.phase_idx + 1) + "/" + p.total_phases + ")";
          } else {
            progressPhaseIdx.textContent = "";
          }

          // Step
          progressStep.textContent = p.step || "-";
          if (p.total_steps > 1) {
            progressStepIdx.textContent = "(" + (p.step_idx + 1) + "/" + p.total_steps + ")";
          } else {
            progressStepIdx.textContent = "";
          }

          // Item (optional)
          if (p.total_items > 0 && p.item) {
            progressItemRow.style.display = "block";
            progressItem.textContent = p.item;
            progressItemIdx.textContent = "(" + p.item_idx + "/" + p.total_items + ")";
          } else {
            progressItemRow.style.display = "none";
          }

          // Message
          progressMessage.textContent = p.message || "-";

          // Progress bar
          const pctVal = Math.min(100, Math.max(0, (p.pct || 0) * 100));
          progressBarFill.style.width = pctVal.toFixed(1) + "%";
          progressPct.textContent = pctVal.toFixed(1) + "%";

          // ETA
          if (p.eta_seconds !== null && p.eta_seconds !== undefined) {
            progressEta.textContent = "ETA " + fmtDurationSec(p.eta_seconds);
          } else {
            progressEta.textContent = "-";
          }

          // Error
          if (p.error) {
            progressErrorRow.style.display = "block";
            progressError.textContent = p.error;
          } else {
            progressErrorRow.style.display = "none";
          }
        } catch (e) {}
      }

      async function tickStatus() {
        try {
          const resp = await fetch(statusUrl);
          if (!resp.ok) return;
          const data = await resp.json();
          const jobs = data.jobs || [];
          const j = jobs.find(x => x && x.id === jobId);
          if (!j) return;
          const st = j.status || "";
          setPill(st);
          if (st === "running" || st === "queued") {
            isActive = true;
          } else {
            isActive = false;
            stopPolling();
          }
        } catch (e) {}
      }

      function stopPolling() {
        if (logTimer) { clearInterval(logTimer); logTimer = null; }
        if (ingestTimer) { clearInterval(ingestTimer); ingestTimer = null; }
        if (statusTimer) { clearInterval(statusTimer); statusTimer = null; }
        if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
      }

      function startPolling() {
        stopPolling();
        const ms = pollMs ? parseInt(pollMs.value, 10) : 2000;
        if (!pausePolling || !pausePolling.checked) {
          logTimer = setInterval(tick, ms);
          statusTimer = setInterval(tickStatus, Math.max(2000, ms));
          ingestTimer = setInterval(tickIngest, 10000);
          progressTimer = setInterval(tickProgress, 2000);
          tick();
          tickStatus();
          tickIngest();
          tickProgress();
        }
      }

      function maybePauseForVisibility() {
        if (document.hidden) {
          stopPolling();
          return;
        }
        if (!isActive) return;
        startPolling();
      }

      if (pausePolling) {
        pausePolling.addEventListener("change", () => {
          if (pausePolling.checked) {
            stopPolling();
          } else {
            if (isActive) startPolling();
          }
        });
      }
      if (pollMs) pollMs.addEventListener("change", () => { if (isActive) startPolling(); });
      document.addEventListener("visibilitychange", maybePauseForVisibility);

      const btnCopyId = document.getElementById("copyJobId");
      const btnCopyCmd = document.getElementById("copyCmd");
      const btnCopyLog = document.getElementById("copyLogPath");
      if (btnCopyId) btnCopyId.addEventListener("click", () => copyText(jobId));
      if (btnCopyCmd) btnCopyCmd.addEventListener("click", () => copyText(document.getElementById("jobCommand").textContent));
      if (btnCopyLog) btnCopyLog.addEventListener("click", () => copyText(document.getElementById("jobLogPath").textContent));

      // Start polling if active (queued/running); otherwise do one-time fetch.
      if (isActive) {
        startPolling();
      } else {
        tick();
        tickIngest();
        tickProgress();
      }
    })();
  </script>
{% endblock %}

